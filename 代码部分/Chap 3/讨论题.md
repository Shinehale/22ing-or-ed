### 25

1. 17-> 1001
2. 45-> 101101
3. 96-> 1100000

### 26

1. `(A+B)*(C+D)*(E+F)` --> `**+AB+CD+EF` 
2. `A+((B+C)*(D+E))` --> `+A*+BC+DE`
3. `A*B*C*D+E+F` --> `++***ABCDEF`

### 27

1. `(A+B)*(C+D)*(E+F)` --> `AB+CD+*EF+*`
2. `A+((B+C)*(D+E))` --> `ABC+DE+*+`
3. `A*B*C*D+E+F` --> `AB*C*D*E+F+`

### 28
1. `(A+B)*(C+D)*(E+F)` --> `AB+CD+*EF+*`
2. `A+((B+C)*(D+E))` --> `ABC+DE+*+`
3. `A*B*C*D+E+F` --> `AB*C*D*E+F+`

### 29
1. 10
2. 15
3. 47

### 30
具体情况详见程序3.40

实现O(1)操作的队列

### 31
若颠倒，将导致原本下一结点的丢失
引用时将发生明显的错误进而报错

### 32
只需要遍历到倒数第二个节点
将next设置成为none即可

### 33
当列表只有一个节点时
只需要将order类的next设置成为none即可